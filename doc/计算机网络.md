# 从输入 URL 到页面展示的完整流程

当您在浏览器地址栏输入一个URL并按下回车键后，浏览器会经历一系列步骤，将对应的网页呈现给您。以下是这个过程的详细描述：

## 1. URL 解析
浏览器首先解析输入的 URL，确定所使用的协议（如 HTTP 或 HTTPS）、主机名（域名）、端口号（如果有指定）、路径以及查询参数等。

## 2. 检查缓存
在发起网络请求之前，浏览器会先检查本地缓存中是否已有所需资源。如果缓存中存在且未过期，浏览器将直接使用缓存内容，避免重复请求。

## 3. DNS 解析
如果缓存中没有所需资源，浏览器会通过 DNS（域名系统）将域名转换为对应的 IP 地址。这个过程可能涉及查询本地缓存、主机文件、路由器缓存、ISP 的 DNS 缓存，或进行 DNS 递归查询。

## 4. 建立 TCP 连接
获取到服务器的 IP 地址后，浏览器与服务器之间需要建立 TCP 连接。这个过程包括三次握手：
- 客户端发送一个 SYN（同步）包，表示请求建立连接。
- 服务器收到后，返回一个 SYN-ACK（同步-确认）包，表示同意建立连接。
- 客户端再发送一个 ACK（确认）包，确认连接建立。

## 5. 发送 HTTP 请求
TCP 连接建立后，浏览器会构建 HTTP 请求，包括请求行、请求头和请求体（如果有，例如 POST 请求）。请求头中可能包含浏览器的相关信息、Cookie 等数据。

## 6. 服务器处理请求并返回响应
服务器接收到 HTTP 请求后，会根据请求内容进行处理，生成响应数据，包括：
- **响应行**（状态码，如 200 表示成功，404 表示未找到）。
- **响应头**（包含内容类型、缓存策略、服务器信息等）。
- **响应体**（如 HTML 文档、JSON 数据等）。
服务器通过 TCP 连接将响应发送回浏览器。

## 7. 浏览器接收并处理响应
浏览器接收到服务器的响应后，会解析响应头，并检查状态码：
- **1XX**（信息类响应）：临时响应，通常不直接展示。
- **2XX**（成功）：浏览器继续处理响应体。
- **3XX**（重定向）：浏览器可能会发起新的请求。
- **4XX**（客户端错误）：通常显示错误页面。
- **5XX**（服务器错误）：表示服务器端发生问题。

## 8. 渲染页面
对于 HTML 响应，浏览器会执行以下步骤：
- **解析 HTML**：将 HTML 文档解析为 DOM（文档对象模型）树结构。
- **解析 CSS**：将 CSS 解析为 CSSOM（CSS 对象模型）树，并进行样式计算。
- **构建渲染树**：结合 DOM 树和 CSSOM 树，生成渲染树，表示页面的可见结构。
- **布局（Layout）**：计算渲染树中各元素的布局信息（位置和大小）。
- **绘制（Painting）**：将布局好的元素绘制到屏幕上，呈现最终页面。

## 9. 关闭连接或保持连接
页面渲染完成后，浏览器可能会：
- 关闭与服务器的 TCP 连接（通过四次挥手完成）。
- 选择保持连接（如使用 HTTP Keep-Alive）以便复用，减少后续请求的延迟。

## 10. 后续资源加载与优化
- **预加载（Preloading）**：浏览器可能会预加载某些资源，以加快未来的访问速度。
- **异步加载（Lazy Loading）**：对于图片、脚本等资源，可能会延迟加载，优化性能。
- **浏览器优化**：现代浏览器会利用 GPU 加速、并行下载等机制提升页面渲染效率。

整个过程涉及浏览器的多个组件和机制，包括网络请求、缓存策略、DNS 解析、TCP/IP 协议、HTTP 协议以及浏览器的渲染引擎等，共同协作将您请求的网页呈现出来。

---

# 2. 为什么浏览器需要三次握手的过程,以及为什么是三次,而不是四次,两次?
在计算机网络中，**三次握手**（Three-Way Handshake）是建立可靠的 TCP 连接所采用的过程。其目的是确保通信双方都具备发送和接收数据的能力，并同步彼此的初始序列号，防止已失效的连接请求报文段突然又传送到服务端，因而产生错误。

## **三次握手的具体过程如下：**

1. **第一次握手**：客户端向服务器发送一个 SYN（同步序列号）报文，表示希望建立连接，并包含客户端的初始序列号。此时，客户端进入 SYN_SENT 状态。

2. **第二次握手**：服务器收到 SYN 报文后，回复一个 SYN-ACK（同步-确认）报文，表示同意建立连接，并包含服务器的初始序列号，同时确认收到了客户端的 SYN 报文。此时，服务器进入 SYN_RCVD 状态。

3. **第三次握手**：客户端收到服务器的 SYN-ACK 报文后，发送一个 ACK（确认）报文，确认已收到服务器的 SYN 报文。此时，客户端和服务器都进入 ESTABLISHED（连接建立）状态，双方可以开始传输数据。

## **为什么需要三次握手，而不是两次或四次？**

- **两次握手的缺陷**：如果采用两次握手，可能会导致已失效的连接请求报文段被服务器误认为是新的连接请求，进而建立错误的连接，浪费服务器资源。三次握手可以有效避免这种情况的发生。
- **三次握手的必要性**：三次握手确保了双方的发送和接收能力都正常，并同步了初始序列号，保证了数据传输的可靠性。

- **四次握手的冗余性**：三次握手已经足以确保连接的可靠建立，增加到四次握手并不会带来更多的可靠性提升，反而会增加通信的开销和延迟，降低连接建立的效率。

因此，TCP 协议采用三次握手机制，以在连接建立时达到可靠性和效率的平衡。

# 3.四次挥手的过程,以及为什么是四次?
在计算机网络中，**四次挥手**是指在终止 TCP 连接时，客户端和服务器之间所进行的四个步骤。其目的是确保双方都已完成数据传输，并安全地关闭连接。

## **四次挥手的具体过程如下：**

1. **第一次挥手**：客户端发送一个 FIN（Finish）报文，表示它已完成数据发送，准备关闭从客户端到服务器的连接。此时，客户端进入 FIN_WAIT_1 状态。

2. **第二次挥手**：服务器收到 FIN 报文后，发送一个 ACK（确认）报文，确认已收到客户端的 FIN 请求。此时，服务器进入 CLOSE_WAIT 状态，客户端进入 FIN_WAIT_2 状态。

3. **第三次挥手**：服务器在确认已无数据需要发送后，向客户端发送一个 FIN 报文，表示服务器也准备关闭从服务器到客户端的连接。此时，服务器进入 LAST_ACK 状态。

4. **第四次挥手**：客户端收到服务器的 FIN 报文后，发送一个 ACK 报文，确认已收到服务器的 FIN 请求。此时，客户端进入 TIME_WAIT 状态，等待一段时间（通常为 2MSL，两个最大报文段生存时间）以确保服务器已收到 ACK 报文，然后客户端和服务器都进入 CLOSED 状态，连接正式关闭。

## **为什么需要四次挥手？**

这是因为 TCP 连接是全双工的，即数据传输在两个方向上是独立的。当一方完成数据发送并发出 FIN 报文时，表示该方向的数据传输已结束，但另一方可能仍有数据需要发送。因此，双方需要分别关闭各自的发送通道，这就需要四次挥手来确保双方都已完成数据传输，并安全地关闭连接。

# TCP与UDP的概念,特点,区别和对应的使用场景

TCP（传输控制协议）和UDP（用户数据报协议）是传输层的两种主要协议，各自具有不同的特点，适用于不同的应用场景。

## **TCP的特点：**

- **面向连接**：在传输数据前，需建立可靠的连接（三次握手），确保双方准备就绪。

- **可靠传输**：提供可靠的服务，确保数据无差错、不丢失、不重复、按序到达。

- **面向字节流**：将应用层报文视为无结构的字节流，分段传输后在目的地重新组装。

- **流量控制和拥塞控制**：通过滑动窗口、重传机制等手段，确保网络稳定性和数据传输质量。

## **UDP的特点：**

- **无连接**：数据传输前无需建立连接，发送端直接将数据报发送到网络上。

- **不保证可靠性**：尽最大努力交付，不保证数据可靠到达，可能出现丢包或乱序。

- **面向报文**：保留应用层报文的边界，一次发送一个报文，接收方直接处理完整报文。

- **开销小、效率高**：首部开销小（仅8个字节），传输速度快，适用于实时性要求高的场景。

## **TCP与UDP的区别：**

- **连接方式**：TCP是面向连接的协议，需要建立连接；UDP是无连接的协议，无需建立连接。

- **可靠性**：TCP提供可靠传输，确保数据完整性；UDP不保证可靠性，可能出现数据丢失或乱序。

- **传输方式**：TCP面向字节流，数据被视为连续的字节流；UDP面向报文，保留报文的完整性。

- **开销**：TCP首部开销大（20字节），UDP首部开销小（8字节）。

## **使用场景：**

- **TCP**：适用于对数据完整性和可靠性要求高的场景，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP）等。

- **UDP**：适用于对实时性要求高、允许少量数据丢失的场景，如视频会议、实时游戏、IP电话等。

---

# HTTP请求常⻅的状态码和字段
HTTP（超文本传输协议）请求由请求行、请求头字段和可选的请求主体组成。服务器在接收到请求后，会返回包含状态行、响应头字段和可选的响应主体的HTTP响应。理解常见的HTTP状态码和头字段对于开发和调试Web应用程序至关重要。

## **常见的HTTP状态码：**

HTTP状态码由三位数字组成，第一位数字表示响应的类别：

- **1xx 信息响应**：请求已被接收，继续处理。
- **2xx 成功**：请求已成功接收、理解并处理。
- **3xx 重定向**：需要进一步的操作以完成请求。
- **4xx 客户端错误**：请求包含错误或无法被处理。
- **5xx 服务器错误**：服务器在处理请求时发生错误。

以下是一些常见的状态码及其含义：

- **200 OK**：请求成功，服务器已返回请求的资源。
- **201 Created**：请求成功，且服务器已创建了新的资源。
- **204 No Content**：服务器成功处理了请求，但没有返回任何内容。
- **301 Moved Permanently**：请求的资源已被永久移动到新位置。
- **302 Found**：请求的资源临时被移动到新位置。
- **304 Not Modified**：资源自上次请求后未被修改，客户端可使用缓存。
- **400 Bad Request**：服务器无法理解请求，由于语法错误。
- **401 Unauthorized**：请求需要用户认证。
- **403 Forbidden**：服务器理解请求，但拒绝执行。
- **404 Not Found**：服务器找不到请求的资源。
- **500 Internal Server Error**：服务器遇到未知错误，无法完成请求。
- **502 Bad Gateway**：服务器作为网关或代理，从上游服务器收到无效响应。
- **503 Service Unavailable**：服务器暂时无法处理请求，通常是由于过载或维护。

## **常见的HTTP头字段：**

HTTP头字段包含在请求和响应中，用于传递元数据。以下是一些常见的头字段：

- **通用头字段：**
  - **Cache-Control**：指定缓存机制，例如`Cache-Control: no-cache`表示不缓存。
  - **Connection**：控制连接选项，例如`Connection: keep-alive`表示保持连接。
  - **Date**：消息发送的日期和时间，例如`Date: Tue, 15 Nov 1994 08:12:31 GMT`。

- **请求头字段：**
  - **Accept**：指定客户端可处理的媒体类型，例如`Accept: text/html`。
  - **Accept-Encoding**：指定可接受的内容编码，例如`Accept-Encoding: gzip, deflate`。
  - **Authorization**：包含认证信息，例如`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`。
  - **Host**：指定服务器的域名和端口号，例如`Host: www.example.com`。
  - **User-Agent**：标识客户端软件的信息，例如`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)`。

- **响应头字段：**
  - **Location**：用于重定向时，指示新的资源位置，例如`Location: http://www.example.org/`。
  - **Server**：包含服务器软件的信息，例如`Server: Apache/2.4.1 (Unix)`。
  - **Set-Cookie**：设置HTTP cookie，例如`Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1`。
  - **Content-Type**：指示响应内容的媒体类型，例如`Content-Type: text/html; charset=UTF-8`。
  - **Content-Length**：指示响应主体的字节长度，例如`Content-Length: 348`。
# 常⻅的请求方式?GET和POST请求的区别?
 HTTP（超文本传输协议）定义了多种请求方法，用于客户端与服务器之间的通信。以下是常见的请求方法及其功能：

- **GET**：从服务器请求指定的资源。
- **POST**：向服务器提交数据，通常用于提交表单或上传文件。
- **PUT**：向服务器上传其最新内容。
- **DELETE**：请求服务器删除指定的资源。
- **HEAD**：与GET方法类似，但服务器仅返回响应头部，不包含实际数据。
- **OPTIONS**：请求服务器返回所支持的HTTP请求方法。
- **TRACE**：回显服务器收到的请求，主要用于测试或诊断。
- **CONNECT**：用于将连接改为隧道方式的代理服务器。

## **GET和POST请求的区别：**

- **参数传递方式**：
  - **GET**：通过URL传递参数，参数包含在URL的查询字符串中。
  - **POST**：通过请求主体传递参数，参数不会显示在URL中。

- **安全性**：
  - **GET**：参数直接暴露在URL中，可能被浏览器缓存或记录在历史记录中，安全性较低。
  - **POST**：参数包含在请求主体中，不会直接显示在URL中，安全性相对较高。

- **数据长度限制**：
  - **GET**：由于URL长度限制，传递的数据量较小。
  - **POST**：由于数据包含在请求主体中，传递的数据量较大。

- **幂等性**：
  - **GET**：通常是幂等的，即多次请求对服务器资源的影响相同。
  - **POST**：通常不是幂等的，即多次请求可能对服务器资源产生不同的影响。

- **缓存**：
  - **GET**：请求可以被缓存。
  - **POST**：请求通常不会被缓存。

了解这些请求方法及其区别，有助于在开发和调试Web应用程序时选择合适的请求方法，确保应用程序的可靠性和安全性。 


在浏览器缓存机制中，主要存在两种策略：**强缓存**和**协商缓存**。这两种策略旨在提高资源加载速度，减少服务器压力，但它们的工作方式有所不同。
# 什么是强缓存和协商缓存

## **强缓存（强制缓存）：**

强缓存是指在缓存有效期内，浏览器直接从本地缓存中获取资源，而不与服务器进行任何通信。这意味着，只要缓存未过期，浏览器就会使用本地副本，返回的状态码为200（从缓存中读取）。强缓存主要通过以下两种HTTP头字段来控制：

- **Expires**：这是HTTP/1.0中的字段，指定资源的过期时间，格式为绝对的GMT时间字符串。例如：`Expires: Mon, 18 Oct 2025 23:59:59 GMT`。浏览器会根据本地时间与该时间比较，决定缓存是否有效。然而，由于客户端和服务器时间可能存在差异，`Expires`的可靠性受到限制。

- **Cache-Control**：这是HTTP/1.1中引入的字段，提供了更精确的缓存控制。其中，`max-age`指令用于指定资源的有效期（以秒为单位）。例如：`Cache-Control: max-age=3600`表示资源在3600秒（即1小时）内是新鲜的。相比`Expires`，`Cache-Control`使用相对时间，避免了客户端和服务器时间不同步的问题。

## **协商缓存（对比缓存）：**

当强缓存失效时，浏览器会与服务器进行通信，验证本地缓存的资源是否仍然有效，这就是协商缓存。具体过程如下：

1. 浏览器发送请求时，会在请求头中包含上次缓存的相关标识（如`If-Modified-Since`或`If-None-Match`）。

2. 服务器接收到请求后，根据这些标识判断资源是否发生变化。

   - 如果资源未修改，服务器返回304 Not Modified状态码，指示浏览器使用本地缓存。

   - 如果资源已修改，服务器返回新的资源和200状态码，浏览器据此更新缓存。

协商缓存主要通过以下两组HTTP头字段实现：

- **Last-Modified / If-Modified-Since**：`Last-Modified`是服务器响应时提供的资源最后修改时间。在后续请求中，浏览器会在请求头中包含`If-Modified-Since`字段，值为之前的`Last-Modified`时间。服务器据此判断资源是否在此时间后被修改。

- **ETag / If-None-Match**：`ETag`是服务器为每个资源生成的唯一标识符（通常是哈希值）。浏览器在后续请求中，会在请求头中包含`If-None-Match`字段，值为之前的`ETag`。服务器通过比较`ETag`值，判断资源是否发生变化。

## **强缓存与协商缓存的区别：**

- **是否与服务器通信**：强缓存不与服务器通信，直接使用本地缓存；协商缓存需要与服务器通信，验证缓存有效性。

- **状态码**：强缓存命中时，返回200状态码，且从缓存中读取（通常在浏览器开发者工具中显示为200 (from cache)）；协商缓存命中时，服务器返回304状态码，指示浏览器使用本地缓存。

需要注意的是，强缓存和协商缓存可以结合使用。当强缓存失效时，浏览器会通过协商缓存机制与服务器确认资源的有效性。如果协商缓存也未命中，浏览器将从服务器获取最新的资源。

了解并合理配置这两种缓存策略，有助于提升网页加载速度，改善用户体验，同时减轻服务器负担。 

# HTTP1.0和HTTP1.1的区别?

HTTP/1.0 和 HTTP/1.1 是 HTTP 协议的两个版本，它们之间有几个重要的区别，主要体现在性能、功能和行为上。以下是 HTTP/1.0 和 HTTP/1.1 之间的几个主要区别：

### 1. **连接管理**
   - **HTTP/1.0**：每次请求都需要建立一个新的 TCP 连接。请求完成后，连接就会被关闭。这种做法导致了大量的连接建立和关闭，增加了延迟和开销。
   - **HTTP/1.1**：引入了持久连接（Persistent Connections），即默认情况下使用同一个 TCP 连接处理多个请求和响应，直到客户端或服务器关闭连接。这样就避免了每次请求都建立新连接的开销。

### 2. **管道化（Pipelining）**
   - **HTTP/1.0**：不支持管道化。
   - **HTTP/1.1**：支持请求管道化。管道化允许客户端在等待服务器响应时，发送多个请求。这样可以减少等待时间，但需要服务器支持并正确处理。

### 3. **缓存控制**
   - **HTTP/1.0**：缓存控制较为简单，主要通过 `Cache-Control` 和 `Expires` 头来控制缓存。
   - **HTTP/1.1**：增加了更多的缓存控制机制，包括 `Cache-Control` 头的细化以及 `ETag` 和 `Last-Modified` 头的引入，从而实现更精确的缓存控制。

### 4. **Host 头**
   - **HTTP/1.0**：在 HTTP/1.0 中，如果一个服务器上有多个网站（虚拟主机），则无法通过 HTTP 请求区分不同的网站，因此只能使用一个网站的主机名。
   - **HTTP/1.1**：引入了 `Host` 头字段，允许客户端在同一个 IP 地址上访问多个不同的虚拟主机（网站）。这样就能支持共享 IP 地址的多个网站。

### 5. **请求和响应的长度**
   - **HTTP/1.0**：使用 `Content-Length` 来指示消息体的长度，但对于某些响应类型不支持分块传输。
   - **HTTP/1.1**：支持分块传输编码（`Transfer-Encoding: chunked`），可以让服务器在不确定最终响应长度的情况下逐步发送数据，尤其适用于动态内容或大文件的传输。

### 6. **错误处理**
   - **HTTP/1.0**：在遇到某些错误时，返回的错误响应并不总是特别清晰。
   - **HTTP/1.1**：改进了错误处理机制，增加了更多的错误代码（如 100-199），以及对特定错误的详细说明。

### 7. **TE（Transfer Encoding）**
   - **HTTP/1.0**：没有 `TE` 头部。
   - **HTTP/1.1**：引入了 `TE` 头部，允许客户端告诉服务器，它能够处理的传输编码格式，通常用于分块传输编码。

### 8. **更多的状态码**
   - **HTTP/1.0**：定义的状态码较少，部分特定场景下缺乏必要的状态码。
   - **HTTP/1.1**：增加了更多的状态码（如 100（继续），101（切换协议），以及更多的 5xx 错误码等）来支持更复杂的应用场景和需求。

### 总结：
- **HTTP/1.1** 主要对性能进行了改进，支持持久连接、管道化、缓存优化、虚拟主机支持、分块传输等功能，大大提高了网页加载效率和灵活性。
- **HTTP/1.0** 是较为简化的协议，适用于初期互联网的需求，但随着互联网应用的扩展，HTTP/1.1 提供了更多的功能以支持更复杂的场景。

总的来说，HTTP/1.1 对比 HTTP/1.0 更加高效和灵活，在现代互联网应用中得到了广泛的应用。

# HTTP2.0与HTTP1.1的区别?
HTTP（超文本传输协议）是用于在客户端和服务器之间传输数据的基础协议。随着互联网的发展，HTTP 协议也经历了多次版本迭代，从 HTTP/1.0 到 HTTP/1.1，再到 HTTP/2，每个版本都有其独特的特性和改进。

### 1. 数据传输格式

- **HTTP/1.1**：采用文本格式传输数据，数据以可读的 ASCII 码形式发送。

- **HTTP/2**：引入了二进制分帧机制，将数据分割成更小的二进制帧进行传输，提高了解析效率和传输性能。 

### 2. 多路复用

- **HTTP/1.1**：使用管道化（Pipelining）来实现多个请求的并发，但在实际应用中，管道化常常被禁用，且存在队头阻塞问题，即一个请求的延迟可能阻塞后续所有请求的处理。

- **HTTP/2**：通过多路复用技术，在一个 TCP 连接上并行发送多个请求和响应，避免了队头阻塞问题，提高了传输效率。 

### 3. 头部压缩

- **HTTP/1.1**：每个请求和响应都会包含完整的头部信息，导致冗余数据传输，增加了网络开销。

- **HTTP/2**：采用 HPACK 算法对头部信息进行压缩，减少了数据量，提高了传输效率。 

### 4. 服务器推送

- **HTTP/1.1**：服务器只能响应客户端明确请求的资源，无法主动发送额外的资源。

- **HTTP/2**：引入了服务器推送机制，服务器可以在客户端请求之前，主动发送相关资源，减少了页面加载时间。 citeturn0search2

### 5. 连接管理

- **HTTP/1.1**：虽然引入了持久连接（Connection: keep-alive），允许在一个连接上发送多个请求，但为了实现并发，通常需要为每个请求建立独立的 TCP 连接，增加了连接管理的复杂性和资源消耗。

- **HTTP/2**：通过多路复用和二进制分帧，在一个连接上高效地处理多个请求，减少了连接数量，降低了延迟和资源消耗。 

总体而言，HTTP/2 在数据传输效率、并发处理和资源利用等方面，相比于 HTTP/1.1 做出了显著改进，提升了 Web 性能和用户体验。 

# HTTPS的工作原理?(https是怎么建立连接的)
HTTPS（超文本传输安全协议）是在 HTTP 协议基础上，结合了传输层安全协议（TLS）或其前身 SSL，用于在计算机网络上进行安全通信的协议。

**HTTPS 连接建立过程：**

1. **客户端发起连接：** 客户端（如浏览器）向服务器发起 HTTPS 请求，通常使用端口 443。

2. **服务器响应：** 服务器返回其数字证书，该证书包含服务器的公钥和由受信任的证书颁发机构（CA）签名的信息。

3. **客户端验证证书：** 客户端验证服务器的数字证书，确保其有效性和可信度。如果验证失败，浏览器会发出警告。

4. **密钥交换：** 客户端生成一个对称密钥（会话密钥），使用服务器的公钥加密后发送给服务器。服务器使用其私钥解密，双方获得相同的会话密钥。

5. **加密通信：** 双方使用协商好的会话密钥，对后续的数据进行加密传输，确保数据的机密性和完整性。

通过以上步骤，HTTPS 协议确保了客户端与服务器之间的数据传输是加密的，防止了数据在传输过程中被窃听或篡改，同时也验证了服务器的身份，防止了中间人攻击。



HTTPS（超文本传输安全协议）通过将标准HTTP协议与传输层安全协议（TLS）相结合，确保计算机网络安全通信。这种整合在客户端（如网页浏览器）和服务器之间提供身份认证、数据完整性和机密性。

**建立HTTPS安全连接的步骤：**

1. **客户端问候（Client Hello）：**
   - 客户端通过发送"Client Hello"消息启动连接过程。该消息包含支持的TLS版本、密码套件（加密算法）及其他必要设置。

2. **服务端问候（Server Hello）：**
   - 服务器返回"Server Hello"消息，从客户端提供的列表中选定双方共同支持的TLS版本和密码套件。

3. **服务器的数字证书：**
   - 服务器向客户端发送其数字证书。该证书包含服务器的公钥，由受信任的证书颁发机构（CA）签发。客户端通过验证此证书确认服务器身份的真实性。

4. **密钥交换：**
   - 客户端与服务器协同生成共享的会话密钥，用于后续通信加密。主要通过以下两种方式实现：
     - **RSA加密：** 客户端生成随机"预主密钥"，使用证书中的服务器公钥加密后发送给服务器。服务器用私钥解密获得预主密钥，双方据此推导出会话密钥。
     - **迪菲-赫尔曼密钥交换（Diffie-Hellman）：** 双方交换公共参数并独立计算共享密钥。该方法支持前向保密（Forward Secrecy），即使未来服务器私钥泄露，历史通信仍保持安全。

5. **切换加密规范：**
   - 客户端和服务器互相发送"更改加密规范"（Change Cipher Spec）消息，确认后续通信将使用协商的会话密钥和密码套件进行加密。

6. **握手完成：**
   - 双方最后发送用会话密钥加密的"完成"（Finished）消息，标志握手过程结束。此时安全加密通道正式建立，应用程序数据可开始安全传输。

此握手过程确保客户端与服务器能安全交换数据，通过身份验证机制和加密保护，实现传输信息的完整性、机密性及通信双方的身份可信。

# HTTPS与HTTP的区别
HTTP（超文本传输协议）和 HTTPS（安全超文本传输协议）是用于在客户端和服务器之间传输数据的协议。它们之间的主要区别在于安全性和数据加密方式。

**主要区别：**

1. **安全性：**
   - **HTTP：** 数据以明文形式传输，容易受到中间人攻击和窃听，敏感信息可能被泄露。
   - **HTTPS：** 在 HTTP 的基础上，通过使用 SSL/TLS 协议对数据进行加密，确保数据在传输过程中保持机密性和完整性，防止窃听和篡改。

2. **端口号：**
   - **HTTP：** 默认使用端口 80。
   - **HTTPS：** 默认使用端口 443。

3. **协议层级：**
   - **HTTP：** 工作在 OSI 模型的应用层。
   - **HTTPS：** 在应用层之下使用 SSL/TLS 协议进行加密，确保数据传输的安全性。

4. **性能：**
   - **HTTP：** 由于没有加密过程，传输速度可能略快。
   - **HTTPS：** 由于数据加密和解密过程，可能会有轻微的性能开销，但随着技术的发展，这种影响已经非常小。

**使用场景：**

- **HTTP：** 适用于传输非敏感信息的场景，例如浏览公开的网页内容。
- **HTTPS：** 适用于需要保护用户隐私和数据安全的场景，如在线支付、登录页面和处理个人信息的网页。

总的来说，HTTPS 提供了比 HTTP 更高的安全性，尤其在处理敏感信息时，强烈建议使用 HTTPS 以保护数据的安全和用户的隐私。 
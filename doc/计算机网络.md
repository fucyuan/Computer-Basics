# 从输入 URL 到页面展示的完整流程

当您在浏览器地址栏输入一个URL并按下回车键后，浏览器会经历一系列步骤，将对应的网页呈现给您。以下是这个过程的详细描述：

## 1. URL 解析
浏览器首先解析输入的 URL，确定所使用的协议（如 HTTP 或 HTTPS）、主机名（域名）、端口号（如果有指定）、路径以及查询参数等。

## 2. 检查缓存
在发起网络请求之前，浏览器会先检查本地缓存中是否已有所需资源。如果缓存中存在且未过期，浏览器将直接使用缓存内容，避免重复请求。

## 3. DNS 解析
如果缓存中没有所需资源，浏览器会通过 DNS（域名系统）将域名转换为对应的 IP 地址。这个过程可能涉及查询本地缓存、主机文件、路由器缓存、ISP 的 DNS 缓存，或进行 DNS 递归查询。

## 4. 建立 TCP 连接
获取到服务器的 IP 地址后，浏览器与服务器之间需要建立 TCP 连接。这个过程包括三次握手：
- 客户端发送一个 SYN（同步）包，表示请求建立连接。
- 服务器收到后，返回一个 SYN-ACK（同步-确认）包，表示同意建立连接。
- 客户端再发送一个 ACK（确认）包，确认连接建立。

## 5. 发送 HTTP 请求
TCP 连接建立后，浏览器会构建 HTTP 请求，包括请求行、请求头和请求体（如果有，例如 POST 请求）。请求头中可能包含浏览器的相关信息、Cookie 等数据。

## 6. 服务器处理请求并返回响应
服务器接收到 HTTP 请求后，会根据请求内容进行处理，生成响应数据，包括：
- **响应行**（状态码，如 200 表示成功，404 表示未找到）。
- **响应头**（包含内容类型、缓存策略、服务器信息等）。
- **响应体**（如 HTML 文档、JSON 数据等）。
服务器通过 TCP 连接将响应发送回浏览器。

## 7. 浏览器接收并处理响应
浏览器接收到服务器的响应后，会解析响应头，并检查状态码：
- **1XX**（信息类响应）：临时响应，通常不直接展示。
- **2XX**（成功）：浏览器继续处理响应体。
- **3XX**（重定向）：浏览器可能会发起新的请求。
- **4XX**（客户端错误）：通常显示错误页面。
- **5XX**（服务器错误）：表示服务器端发生问题。

## 8. 渲染页面
对于 HTML 响应，浏览器会执行以下步骤：
- **解析 HTML**：将 HTML 文档解析为 DOM（文档对象模型）树结构。
- **解析 CSS**：将 CSS 解析为 CSSOM（CSS 对象模型）树，并进行样式计算。
- **构建渲染树**：结合 DOM 树和 CSSOM 树，生成渲染树，表示页面的可见结构。
- **布局（Layout）**：计算渲染树中各元素的布局信息（位置和大小）。
- **绘制（Painting）**：将布局好的元素绘制到屏幕上，呈现最终页面。

## 9. 关闭连接或保持连接
页面渲染完成后，浏览器可能会：
- 关闭与服务器的 TCP 连接（通过四次挥手完成）。
- 选择保持连接（如使用 HTTP Keep-Alive）以便复用，减少后续请求的延迟。

## 10. 后续资源加载与优化
- **预加载（Preloading）**：浏览器可能会预加载某些资源，以加快未来的访问速度。
- **异步加载（Lazy Loading）**：对于图片、脚本等资源，可能会延迟加载，优化性能。
- **浏览器优化**：现代浏览器会利用 GPU 加速、并行下载等机制提升页面渲染效率。

整个过程涉及浏览器的多个组件和机制，包括网络请求、缓存策略、DNS 解析、TCP/IP 协议、HTTP 协议以及浏览器的渲染引擎等，共同协作将您请求的网页呈现出来。

---

# 2. 为什么浏览器需要三次握手的过程,以及为什么是三次,而不是四次,两次?
在计算机网络中，**三次握手**（Three-Way Handshake）是建立可靠的 TCP 连接所采用的过程。其目的是确保通信双方都具备发送和接收数据的能力，并同步彼此的初始序列号，防止已失效的连接请求报文段突然又传送到服务端，因而产生错误。

## **三次握手的具体过程如下：**

1. **第一次握手**：客户端向服务器发送一个 SYN（同步序列号）报文，表示希望建立连接，并包含客户端的初始序列号。此时，客户端进入 SYN_SENT 状态。

2. **第二次握手**：服务器收到 SYN 报文后，回复一个 SYN-ACK（同步-确认）报文，表示同意建立连接，并包含服务器的初始序列号，同时确认收到了客户端的 SYN 报文。此时，服务器进入 SYN_RCVD 状态。

3. **第三次握手**：客户端收到服务器的 SYN-ACK 报文后，发送一个 ACK（确认）报文，确认已收到服务器的 SYN 报文。此时，客户端和服务器都进入 ESTABLISHED（连接建立）状态，双方可以开始传输数据。

## **为什么需要三次握手，而不是两次或四次？**

- **两次握手的缺陷**：如果采用两次握手，可能会导致已失效的连接请求报文段被服务器误认为是新的连接请求，进而建立错误的连接，浪费服务器资源。三次握手可以有效避免这种情况的发生。
- **三次握手的必要性**：三次握手确保了双方的发送和接收能力都正常，并同步了初始序列号，保证了数据传输的可靠性。

- **四次握手的冗余性**：三次握手已经足以确保连接的可靠建立，增加到四次握手并不会带来更多的可靠性提升，反而会增加通信的开销和延迟，降低连接建立的效率。

因此，TCP 协议采用三次握手机制，以在连接建立时达到可靠性和效率的平衡。

# 3.四次挥手的过程,以及为什么是四次?
在计算机网络中，**四次挥手**是指在终止 TCP 连接时，客户端和服务器之间所进行的四个步骤。其目的是确保双方都已完成数据传输，并安全地关闭连接。

## **四次挥手的具体过程如下：**

1. **第一次挥手**：客户端发送一个 FIN（Finish）报文，表示它已完成数据发送，准备关闭从客户端到服务器的连接。此时，客户端进入 FIN_WAIT_1 状态。

2. **第二次挥手**：服务器收到 FIN 报文后，发送一个 ACK（确认）报文，确认已收到客户端的 FIN 请求。此时，服务器进入 CLOSE_WAIT 状态，客户端进入 FIN_WAIT_2 状态。

3. **第三次挥手**：服务器在确认已无数据需要发送后，向客户端发送一个 FIN 报文，表示服务器也准备关闭从服务器到客户端的连接。此时，服务器进入 LAST_ACK 状态。

4. **第四次挥手**：客户端收到服务器的 FIN 报文后，发送一个 ACK 报文，确认已收到服务器的 FIN 请求。此时，客户端进入 TIME_WAIT 状态，等待一段时间（通常为 2MSL，两个最大报文段生存时间）以确保服务器已收到 ACK 报文，然后客户端和服务器都进入 CLOSED 状态，连接正式关闭。

## **为什么需要四次挥手？**

这是因为 TCP 连接是全双工的，即数据传输在两个方向上是独立的。当一方完成数据发送并发出 FIN 报文时，表示该方向的数据传输已结束，但另一方可能仍有数据需要发送。因此，双方需要分别关闭各自的发送通道，这就需要四次挥手来确保双方都已完成数据传输，并安全地关闭连接。

# TCP与UDP的概念,特点,区别和对应的使用场景

TCP（传输控制协议）和UDP（用户数据报协议）是传输层的两种主要协议，各自具有不同的特点，适用于不同的应用场景。

## **TCP的特点：**

- **面向连接**：在传输数据前，需建立可靠的连接（三次握手），确保双方准备就绪。

- **可靠传输**：提供可靠的服务，确保数据无差错、不丢失、不重复、按序到达。

- **面向字节流**：将应用层报文视为无结构的字节流，分段传输后在目的地重新组装。

- **流量控制和拥塞控制**：通过滑动窗口、重传机制等手段，确保网络稳定性和数据传输质量。

## **UDP的特点：**

- **无连接**：数据传输前无需建立连接，发送端直接将数据报发送到网络上。

- **不保证可靠性**：尽最大努力交付，不保证数据可靠到达，可能出现丢包或乱序。

- **面向报文**：保留应用层报文的边界，一次发送一个报文，接收方直接处理完整报文。

- **开销小、效率高**：首部开销小（仅8个字节），传输速度快，适用于实时性要求高的场景。

## **TCP与UDP的区别：**

- **连接方式**：TCP是面向连接的协议，需要建立连接；UDP是无连接的协议，无需建立连接。

- **可靠性**：TCP提供可靠传输，确保数据完整性；UDP不保证可靠性，可能出现数据丢失或乱序。

- **传输方式**：TCP面向字节流，数据被视为连续的字节流；UDP面向报文，保留报文的完整性。

- **开销**：TCP首部开销大（20字节），UDP首部开销小（8字节）。

## **使用场景：**

- **TCP**：适用于对数据完整性和可靠性要求高的场景，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP）等。

- **UDP**：适用于对实时性要求高、允许少量数据丢失的场景，如视频会议、实时游戏、IP电话等。

---

# HTTP请求常⻅的状态码和字段
HTTP（超文本传输协议）请求由请求行、请求头字段和可选的请求主体组成。服务器在接收到请求后，会返回包含状态行、响应头字段和可选的响应主体的HTTP响应。理解常见的HTTP状态码和头字段对于开发和调试Web应用程序至关重要。

## **常见的HTTP状态码：**

HTTP状态码由三位数字组成，第一位数字表示响应的类别：

- **1xx 信息响应**：请求已被接收，继续处理。
- **2xx 成功**：请求已成功接收、理解并处理。
- **3xx 重定向**：需要进一步的操作以完成请求。
- **4xx 客户端错误**：请求包含错误或无法被处理。
- **5xx 服务器错误**：服务器在处理请求时发生错误。

以下是一些常见的状态码及其含义：

- **200 OK**：请求成功，服务器已返回请求的资源。
- **201 Created**：请求成功，且服务器已创建了新的资源。
- **204 No Content**：服务器成功处理了请求，但没有返回任何内容。
- **301 Moved Permanently**：请求的资源已被永久移动到新位置。
- **302 Found**：请求的资源临时被移动到新位置。
- **304 Not Modified**：资源自上次请求后未被修改，客户端可使用缓存。
- **400 Bad Request**：服务器无法理解请求，由于语法错误。
- **401 Unauthorized**：请求需要用户认证。
- **403 Forbidden**：服务器理解请求，但拒绝执行。
- **404 Not Found**：服务器找不到请求的资源。
- **500 Internal Server Error**：服务器遇到未知错误，无法完成请求。
- **502 Bad Gateway**：服务器作为网关或代理，从上游服务器收到无效响应。
- **503 Service Unavailable**：服务器暂时无法处理请求，通常是由于过载或维护。

## **常见的HTTP头字段：**

HTTP头字段包含在请求和响应中，用于传递元数据。以下是一些常见的头字段：

- **通用头字段：**
  - **Cache-Control**：指定缓存机制，例如`Cache-Control: no-cache`表示不缓存。
  - **Connection**：控制连接选项，例如`Connection: keep-alive`表示保持连接。
  - **Date**：消息发送的日期和时间，例如`Date: Tue, 15 Nov 1994 08:12:31 GMT`。

- **请求头字段：**
  - **Accept**：指定客户端可处理的媒体类型，例如`Accept: text/html`。
  - **Accept-Encoding**：指定可接受的内容编码，例如`Accept-Encoding: gzip, deflate`。
  - **Authorization**：包含认证信息，例如`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`。
  - **Host**：指定服务器的域名和端口号，例如`Host: www.example.com`。
  - **User-Agent**：标识客户端软件的信息，例如`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)`。

- **响应头字段：**
  - **Location**：用于重定向时，指示新的资源位置，例如`Location: http://www.example.org/`。
  - **Server**：包含服务器软件的信息，例如`Server: Apache/2.4.1 (Unix)`。
  - **Set-Cookie**：设置HTTP cookie，例如`Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1`。
  - **Content-Type**：指示响应内容的媒体类型，例如`Content-Type: text/html; charset=UTF-8`。
  - **Content-Length**：指示响应主体的字节长度，例如`Content-Length: 348`。
# 常⻅的请求方式?GET和POST请求的区别?
 HTTP（超文本传输协议）定义了多种请求方法，用于客户端与服务器之间的通信。以下是常见的请求方法及其功能：

- **GET**：从服务器请求指定的资源。
- **POST**：向服务器提交数据，通常用于提交表单或上传文件。
- **PUT**：向服务器上传其最新内容。
- **DELETE**：请求服务器删除指定的资源。
- **HEAD**：与GET方法类似，但服务器仅返回响应头部，不包含实际数据。
- **OPTIONS**：请求服务器返回所支持的HTTP请求方法。
- **TRACE**：回显服务器收到的请求，主要用于测试或诊断。
- **CONNECT**：用于将连接改为隧道方式的代理服务器。

## **GET和POST请求的区别：**

- **参数传递方式**：
  - **GET**：通过URL传递参数，参数包含在URL的查询字符串中。
  - **POST**：通过请求主体传递参数，参数不会显示在URL中。

- **安全性**：
  - **GET**：参数直接暴露在URL中，可能被浏览器缓存或记录在历史记录中，安全性较低。
  - **POST**：参数包含在请求主体中，不会直接显示在URL中，安全性相对较高。

- **数据长度限制**：
  - **GET**：由于URL长度限制，传递的数据量较小。
  - **POST**：由于数据包含在请求主体中，传递的数据量较大。

- **幂等性**：
  - **GET**：通常是幂等的，即多次请求对服务器资源的影响相同。
  - **POST**：通常不是幂等的，即多次请求可能对服务器资源产生不同的影响。

- **缓存**：
  - **GET**：请求可以被缓存。
  - **POST**：请求通常不会被缓存。

了解这些请求方法及其区别，有助于在开发和调试Web应用程序时选择合适的请求方法，确保应用程序的可靠性和安全性。 


在浏览器缓存机制中，主要存在两种策略：**强缓存**和**协商缓存**。这两种策略旨在提高资源加载速度，减少服务器压力，但它们的工作方式有所不同。
# 什么是强缓存和协商缓存

## **强缓存（强制缓存）：**

强缓存是指在缓存有效期内，浏览器直接从本地缓存中获取资源，而不与服务器进行任何通信。这意味着，只要缓存未过期，浏览器就会使用本地副本，返回的状态码为200（从缓存中读取）。强缓存主要通过以下两种HTTP头字段来控制：

- **Expires**：这是HTTP/1.0中的字段，指定资源的过期时间，格式为绝对的GMT时间字符串。例如：`Expires: Mon, 18 Oct 2025 23:59:59 GMT`。浏览器会根据本地时间与该时间比较，决定缓存是否有效。然而，由于客户端和服务器时间可能存在差异，`Expires`的可靠性受到限制。

- **Cache-Control**：这是HTTP/1.1中引入的字段，提供了更精确的缓存控制。其中，`max-age`指令用于指定资源的有效期（以秒为单位）。例如：`Cache-Control: max-age=3600`表示资源在3600秒（即1小时）内是新鲜的。相比`Expires`，`Cache-Control`使用相对时间，避免了客户端和服务器时间不同步的问题。

## **协商缓存（对比缓存）：**

当强缓存失效时，浏览器会与服务器进行通信，验证本地缓存的资源是否仍然有效，这就是协商缓存。具体过程如下：

1. 浏览器发送请求时，会在请求头中包含上次缓存的相关标识（如`If-Modified-Since`或`If-None-Match`）。

2. 服务器接收到请求后，根据这些标识判断资源是否发生变化。

   - 如果资源未修改，服务器返回304 Not Modified状态码，指示浏览器使用本地缓存。

   - 如果资源已修改，服务器返回新的资源和200状态码，浏览器据此更新缓存。

协商缓存主要通过以下两组HTTP头字段实现：

- **Last-Modified / If-Modified-Since**：`Last-Modified`是服务器响应时提供的资源最后修改时间。在后续请求中，浏览器会在请求头中包含`If-Modified-Since`字段，值为之前的`Last-Modified`时间。服务器据此判断资源是否在此时间后被修改。

- **ETag / If-None-Match**：`ETag`是服务器为每个资源生成的唯一标识符（通常是哈希值）。浏览器在后续请求中，会在请求头中包含`If-None-Match`字段，值为之前的`ETag`。服务器通过比较`ETag`值，判断资源是否发生变化。

## **强缓存与协商缓存的区别：**

- **是否与服务器通信**：强缓存不与服务器通信，直接使用本地缓存；协商缓存需要与服务器通信，验证缓存有效性。

- **状态码**：强缓存命中时，返回200状态码，且从缓存中读取（通常在浏览器开发者工具中显示为200 (from cache)）；协商缓存命中时，服务器返回304状态码，指示浏览器使用本地缓存。

需要注意的是，强缓存和协商缓存可以结合使用。当强缓存失效时，浏览器会通过协商缓存机制与服务器确认资源的有效性。如果协商缓存也未命中，浏览器将从服务器获取最新的资源。

了解并合理配置这两种缓存策略，有助于提升网页加载速度，改善用户体验，同时减轻服务器负担。 